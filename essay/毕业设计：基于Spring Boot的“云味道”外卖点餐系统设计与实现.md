好的，明白你的意思了。你是希望先得到一份**完全原汁原味、不做任何修改**的拼接版论文全文。

我已将 `thesis_draft.md`（第1-3章）、`thesis_part_2.md`（第4章）和 `thesis_part_3.md`（第5-7章）按顺序直接拼接如下：

------

# 毕业设计：基于Spring Boot的“云味道”外卖点餐系统设计与实现

**目录**

[TOC]

------

# 1 绪论

## 1.1 研究背景

随着移动互联网技术的飞速发展和智能手机的普及，人们的生活方式发生了翻天覆地的变化，“互联网+”模式已深入渗透到社会的各个角落。餐饮行业作为与人们日常生活息息相关的传统服务业，首当其冲地受到了互联网浪潮的洗礼。传统的餐饮经营模式面临着成本高、效率低、获客难等诸多痛点，数字化转型已成为餐饮企业生存和发展的必然选择。

近年来，外卖服务作为餐饮行业的重要组成部分，呈现出爆发式增长的态势。根据相关统计数据显示，中国外卖市场规模已突破万亿元大关，用户规模数以亿计。美团、饿了么等第三方外卖平台的崛起，极大地方便了消费者的日常生活，也为餐饮商家提供了广阔的销售渠道。然而，随着平台垄断格局的形成，高昂的佣金抽成、竞价排名费用以及用户数据的非私有化，逐渐成为制约中小型餐饮商家利润增长的瓶颈。许多商家开始寻求建立自有的外卖点餐系统，以降低运营成本、沉淀私域流量、提升品牌形象。

在此背景下，开发一套功能完善、性能稳定、易于维护的“云味道”外卖点餐系统具有重要的现实意义。该系统旨在为餐饮商家提供一个自主可控的线上经营平台，实现从菜品管理、订单处理到数据分析的全流程数字化管理，帮助商家降本增效，提升核心竞争力。

## 1.2 国内外研究现状

### 1.2.1 国内研究现状

国内餐饮信息化建设起步较晚，但发展迅猛。早期的餐饮管理系统（MIS）主要局限于单机版的点菜、收银功能，数据孤岛现象严重。随着云计算和大数据技术的发展，SaaS（软件即服务）模式的餐饮软件逐渐成为主流。

目前，国内市场上的外卖点餐系统主要分为两类：

1. **第三方聚合平台**：以美团、饿了么为代表。这些平台流量巨大，技术成熟，但对商家的控制力较强，佣金比例通常在15%-25%之间，且商家难以获取用户的详细行为数据，不利于二次营销。
2. **品牌自营小程序/APP**：肯德基、麦当劳、喜茶等大型连锁品牌均开发了自有的移动端点餐系统。这些系统通常与微信生态深度融合（如微信小程序），用户体验流畅，且能够完全掌握用户数据。对于中小型商家而言，虽然开发独立APP成本过高，但基于微信小程序的轻量级点餐系统已成为热门选择。

在技术层面，国内开发者广泛采用Java作为后端开发语言，结合Spring Boot、MyBatis等开源框架构建微服务架构，以应对高并发、高可用的业务场景。前端技术则从传统的JSP转向Vue.js、React等前后端分离架构，极大提升了用户体验。

### 1.2.2 国外研究现状

国外餐饮外卖市场同样发展成熟。美国的Grubhub、Uber Eats、DoorDash以及英国的Deliveroo等平台占据了主要市场份额。与国内相比，国外的外卖平台更注重配送效率的优化和个性化推荐算法的应用。

在技术研究方面，国外在餐饮推荐系统、路径规划算法以及无人配送技术（如无人机、自动驾驶小车）方面处于领先地位。例如，Uber Eats利用大数据预测用户需求，优化骑手调度算法，显著缩短了配送时间。此外，国外开源社区活跃，涌现了许多优秀的开源电商和餐饮解决方案（如Magento、Odoo等），为国内系统的设计提供了宝贵的参考。

### 1.3 研究意义

本课题的研究意义主要体现在以下几个方面：

1. **经济价值**：通过构建自有的外卖点餐系统，商家可以摆脱第三方平台的高额佣金束缚，提高利润率。同时，系统提供的精细化报表分析功能，有助于商家优化菜品结构，减少食材浪费，控制成本。
2. **管理价值**：系统实现了业务流程的标准化和自动化。从用户下单、厨房接单到骑手配送，全流程在线流转，减少了人工沟通成本和错单漏单率。后台管理系统能够实时监控店铺运营状态，提升管理效率。
3. **技术实践**：本项目采用当前主流的前后端分离开发模式，后端基于Spring Boot框架，前端结合Vue.js和微信小程序。通过本项目的实施，能够深入理解企业级应用架构的设计原则，掌握Redis缓存、WebSocket消息推送、MySQL数据库优化等关键技术，为今后从事复杂系统开发积累宝贵经验。
4. **用户体验**：针对C端用户设计的小程序界面简洁直观，无需下载安装即可使用，降低了使用门槛。系统支持多种口味选择、订单实时追踪等功能，能够显著提升用户的点餐体验。

## 1.4 章节安排

本文共分为七章，具体安排如下：

- **第一章 绪论**：阐述课题的研究背景、国内外的研究现状以及研究的目的和意义，总体介绍论文的结构。
- **第二章 相关理论与技术**：详细介绍系统开发所涉及的核心技术，包括Java语言、Spring Boot框架、MySQL数据库、Redis缓存技术、WebSocket通信机制以及Vue.js前端框架。
- **第三章 系统分析**：从可行性、功能需求、非功能需求三个维度对系统进行全面分析，绘制用例图，明确系统的业务边界和用户角色。
- **第四章 系统设计**：进行系统的总体架构设计、功能模块划分以及数据库设计（概念结构与逻辑结构），并给出关键业务的流程图和时序图。
- **第五章 系统实现**：展示系统的核心功能实现界面，并结合关键代码片段详细讲解后端逻辑与前端交互的实现过程。
- **第六章 系统测试**：制定测试方案，对系统的主要功能模块进行黑盒测试，验证系统的功能完整性和稳定性，并对测试结果进行分析。
- **第七章 总结与展望**：总结全文的研究成果，指出系统存在的不足之处，并对未来的改进方向提出展望。

------

# 2 相关理论与技术

## 2.1 Java 语言

Java是一种面向对象的编程语言，由Sun Microsystems公司（后被Oracle收购）于1995年推出。Java具有“一次编写，到处运行”（Write Once, Run Anywhere）的跨平台特性，这得益于Java虚拟机（JVM）的架构设计。

在本系统中，Java作为后端核心开发语言，主要发挥了以下优势：

1. **面向对象**：Java的封装、继承、多态特性使得代码结构清晰，易于维护和扩展。
2. **丰富的生态系统**：Java拥有庞大的开源社区和第三方库支持，如Apache Commons、Google Guava等，极大地提高了开发效率。
3. **多线程与高并发**：Java内置了强大的多线程支持，结合JUC（java.util.concurrent）包，能够有效处理外卖高峰期的高并发请求。

## 2.2 MySQL数据库

MySQL是目前最流行的开源关系型数据库管理系统之一。它基于Structured Query Language（SQL）进行数据管理，具有体积小、速度快、成本低等特点。

本系统选用MySQL 8.0版本作为持久层存储方案，主要基于以下考虑：

1. **事务支持**：MySQL的InnoDB存储引擎支持ACID（原子性、一致性、隔离性、持久性）事务特性，确保了订单支付、库存扣减等关键业务的数据一致性。
2. **高性能**：通过合理的索引设计（如B+树索引）和查询优化，MySQL能够毫秒级响应海量数据的增删改查操作。
3. **可扩展性**：支持主从复制、读写分离等高可用架构，便于未来随着业务量的增长进行水平扩展。

## 2.3 Spring Boot框架

Spring Boot是Spring家族中的明星项目，旨在简化Spring应用的初始搭建和开发过程。它遵循“约定优于配置”的原则，通过自动配置（Auto-configuration）机制，省去了传统Spring项目中繁琐的XML配置。

在本系统中，Spring Boot扮演了“骨架”的角色：

1. **内嵌容器**：Spring Boot内嵌了Tomcat服务器，使得项目可以打包成一个可执行的JAR文件，简化了部署流程。
2. **依赖管理**：通过spring-boot-starter-parent统一管理依赖版本，避免了版本冲突问题。
3. **整合能力**：能够无缝整合MyBatis、Redis、Swagger等第三方技术栈，提供了开箱即用的开发体验。

## 2.4 MyBatis与MyBatis Plus

MyBatis是一款优秀的持久层框架，它支持自定义SQL、存储过程以及高级映射。与Hibernate等全自动ORM框架相比，MyBatis更加灵活，允许开发者直接编写SQL语句，从而进行精细化的性能调优。

本系统采用MyBatis作为DAO（Data Access Object）层的实现技术，主要用于：

1. **SQL与代码分离**：将SQL语句编写在XML映射文件中，通过Mapper接口进行调用，降低了代码的耦合度。
2. **动态SQL**：利用MyBatis提供的`<if>`、`<foreach>`等标签，可以灵活构建复杂的动态查询条件，如订单的多条件筛选。

## 2.5 Redis 缓存技术

Redis（Remote Dictionary Server）是一个开源的、基于内存的数据结构存储系统，可以用作数据库、缓存和消息中间件。

在外卖系统中，Redis主要应用于以下场景：

1. **缓存菜品数据**：用户端浏览菜单是高频操作，将菜品和套餐数据缓存到Redis中（如`dish_分类ID`），可以极大减少对MySQL的访问压力，提升页面加载速度。
2. **用户购物车**：由于购物车数据变动频繁且临时性强，将其存储在Redis中（Hash结构）比存储在MySQL中更为高效。
3. **验证码存储**：用户登录时的验证码具有时效性，利用Redis的TTL（Time To Live）过期机制可以轻松实现。

## 2.6 WebSocket 实时通信

WebSocket是一种在单个TCP连接上进行全双工通信的协议。与传统的HTTP请求-响应模式不同，WebSocket允许服务器主动向客户端推送数据。

在本系统中，WebSocket主要解决了“商家接单”的实时性问题。当用户在小程序端下单支付成功后，后端服务器会通过WebSocket向商家管理后台推送一条消息，前端接收到消息后通过语音播报提醒商家“您有新的外卖订单”，从而避免了商家通过轮询方式查询订单导致的延迟和资源浪费。

## 2.7 Vue.js 与 Element UI

### 2.7.1 Vue.js

Vue.js 是一套用于构建用户界面的渐进式JavaScript框架。它采用MVVM（Model-View-ViewModel）模式，通过双向数据绑定和组件化开发，使得前端代码更加简洁高效。本系统的后台管理端采用Vue.js构建单页面应用（SPA）。

### 2.7.2 Element UI

Element UI 是一套基于 Vue 2.0 的桌面端组件库。它提供了丰富的UI组件，如表格、表单、对话框、导航菜单等。本系统使用Element UI快速搭建了美观、风格统一的后台管理界面，极大地缩短了开发周期。

## 2.8 本章小结

本章详细介绍了“云味道”外卖点餐系统所采用的关键技术栈。后端以Spring Boot为核心，整合了MyBatis进行数据持久化，利用Redis提升系统性能，通过WebSocket实现消息实时推送。前端则采用了Vue.js和Element UI构建管理后台，微信小程序承载C端业务。这些技术的合理选型和有机结合，为系统的稳定运行和高效开发奠定了坚实的基础。

------

# 3 系统分析

## 3.1 可行性分析

### 3.1.1 技术可行性

本系统采用Java作为后端开发语言，其生态成熟、稳定性高，适合构建企业级应用。Spring Boot框架极大简化了开发流程，MyBatis提供了灵活的数据访问能力。前端使用的Vue.js和微信小程序技术均已十分成熟，拥有大量的开发文档和社区支持。Redis和MySQL的组合能够满足系统对高性能和数据一致性的要求。开发团队成员对上述技术均有一定掌握，因此在技术上是完全可行的。

### 3.1.2 经济可行性

系统的开发成本主要集中在人力成本和少量的服务器租赁费用。相比于入驻第三方外卖平台每年需缴纳的高额佣金（通常为营业额的20%左右），自建系统的维护成本相对较低。一旦系统投入使用，商家可以长期免费使用，不仅节省了平台抽成，还能通过私域流量运营带来长期的经济效益。因此，从经济角度来看，本项目具有较高的投资回报率。

### 3.1.3 操作可行性

系统设计遵循“用户至上”的原则。C端小程序界面简洁明了，符合大众操作习惯，用户无需培训即可上手点餐。B端管理后台采用可视化的操作界面，功能布局合理，商家只需具备基本的电脑操作技能即可完成菜品维护、订单处理等工作。此外，系统将提供详细的操作手册，确保用户能顺利使用。

## 3.2 系统总需求分析

“云味道”外卖点餐系统旨在搭建一个连接商家与消费者的在线服务平台。

**对于消费者（用户端）**，系统需要提供：

1. 便捷的浏览体验：能够快速查看餐厅的菜品分类、详情及价格。
2. 流畅的下单流程：支持购物车管理、规格选择（如微辣/中辣）、地址管理及在线支付。
3. 透明的订单状态：能够实时查看订单的制作、配送进度。

**对于商家（管理端）**，系统需要提供：

1. 高效的订单处理：新订单语音提醒、快速接单/拒单/派送。
2. 灵活的商品管理：支持菜品/套餐的新增、修改、停售及图片上传。
3. 精准的数据报表：提供营业额、销量排名等可视化数据，辅助经营决策。

## 3.3 用户角色分析

本系统主要包含两类用户角色：

### 3.3.1 系统管理员（商家）

管理员是系统的核心使用者，拥有最高权限。其主要职责包括：

- **基础设置**：管理员工账号，设置店铺营业状态。
- **商品维护**：管理菜品和套餐，包括分类设置、价格调整、口味配置。
- **订单中心**：处理所有状态的订单，包括待接单、待派送、退单处理等。
- **数据统计**：查看每日/每月的经营报表。

### 3.3.2 消费者（C端用户）

消费者是系统的服务对象。其主要行为包括：

- **浏览点餐**：浏览菜单，选择规格，加入购物车。
- **个人中心**：管理收货地址，查看历史订单。
- **支付交易**：通过微信支付完成订单结算。

## 3.4 系统用例分析

### 3.4.1 系统总用例

系统总体用例图涵盖了管理员和用户两大角色的核心功能。

- **管理员用例**：登录、退出、员工管理、分类管理、菜品管理、套餐管理、订单管理、报表统计。
- **用户用例**：微信登录、浏览菜品、加入购物车、下单支付、订单查询、地址管理。

### 3.4.2 菜品管理功能需求分析

菜品是外卖系统的核心资源。管理员需要对菜品进行全生命周期的管理。

- **用例描述**：管理员登录后台，进入菜品管理模块，可以查看当前所有菜品列表。
- **功能点**：
  1. **新增菜品**：填写菜品名称、价格、描述，选择所属分类，配置口味（如：甜度、辣度），上传菜品图片。
  2. **修改菜品**：回显已有信息，允许修改价格、状态等。
  3. **批量删除**：支持选中多个停售状态的菜品进行删除；起售中的菜品不可删除。
  4. **起售/停售**：一键切换菜品的销售状态。

### 3.4.3 套餐管理功能需求分析

为了丰富销售策略，商家通常会推出套餐（如：单人豪华午餐）。

- **用例描述**：管理员将多个现有的菜品组合成一个套餐。
- **功能点**：
  1. **新增套餐**：设置套餐名称、价格、分类，并从现有菜品库中选择若干菜品加入套餐。
  2. **修改套餐**：增加或减少套餐内的菜品，调整价格。
  3. **起售/停售**：控制套餐是否在小程序端展示。

### 3.4.4 订单管理功能需求分析

订单管理是业务流转的中枢。

- **用例描述**：系统根据订单状态（待付款、待接单、待派送、派送中、已完成、已取消）进行分类管理。
- **功能点**：
  1. **接单**：商家收到“待接单”订单，核实无误后点击接单，订单状态变为“待派送”。
  2. **拒单**：对于无法制作的订单（如食材不足），商家选择拒单并填写原因，系统自动发起退款。
  3. **派送**：餐品制作完成后，点击派送，状态变为“派送中”。
  4. **取消订单**：用户在未接单前可直接取消；接单后取消需商家审核。

### 3.4.5 分类与员工管理功能需求分析

- **分类管理**：支持“菜品分类”和“套餐分类”的增删改查及排序，分类的启用/禁用状态直接影响C端菜单的展示结构。
- **员工管理**：超级管理员可以创建普通员工账号，便于多人协作管理店铺。

### 3.4.6 数据统计功能需求分析

数据驱动经营。

- **用例描述**：管理员查看特定时间段内的经营数据。
- **功能点**：
  1. **营业额统计**：展示每日营业额趋势折线图。
  2. **用户统计**：展示新增用户数和总用户数。
  3. **订单统计**：展示订单完成率、有效订单数。
  4. **销量排名**：展示销量前10名的菜品/套餐，帮助商家淘汰冷门菜品。

## 3.5 系统非功能性需求

1. **性能需求**：
   - C端首页加载时间不超过1.5秒。
   - 支持至少500个用户同时在线点餐。
   - 接口响应时间95%在200ms以内。
2. **安全性需求**：
   - 用户密码及员工密码需加密存储（如MD5）。
   - 所有API接口需进行Token认证（JWT），防止未授权访问。
   - 防止SQL注入和XSS攻击。
3. **可靠性需求**：
   - 系统需7x24小时不间断运行。
   - 数据每日自动备份，防止数据丢失。

## 3.6 本章小结

本章从技术、经济、操作三个方面论证了系统的可行性，并对系统的用户角色进行了划分。通过详细的用例分析，明确了菜品管理、订单管理、数据统计等核心功能模块的需求，同时规定了系统的性能和安全指标。这为后续的系统设计和实现提供了明确的指导方向。

# 4 系统设计

## 4.1 系统功能结构设计

系统采用B/S（Browser/Server）架构，主要分为两个客户端：后台管理端（Web）和用户端（微信小程序）。

### 4.1.1 后台管理端功能结构

后台管理端面向餐饮商家，主要功能模块如下：

- **员工管理**：负责新增员工、编辑员工信息、禁用/启用员工账号。
- **分类管理**：维护菜品分类和套餐分类，设置分类排序。
- **菜品管理**：实现菜品的增删改查，支持图片上传和口味配置。
- **套餐管理**：实现套餐的增删改查，关联菜品。
- **订单管理**：处理待接单、待派送、派送中、已完成、已取消等各状态订单。
- **数据统计**：提供营业额、用户、订单、销量排名的可视化报表。

### 4.1.2 用户端（小程序）功能结构

用户端面向消费者，主要功能模块如下：

- **登录/注册**：基于微信授权的一键登录。
- **点餐首页**：展示轮播图、菜品分类、菜品列表、购物车入口。
- **购物车**：添加/减少商品、清空购物车、去结算。
- **订单中心**：提交订单、支付订单、查看订单状态、再来一单。
- **个人中心**：地址簿管理、历史订单查询。

## 4.2 系统技术架构设计

本系统采用经典的分层架构设计，自下而上分为：

1. **数据层（Data Layer）**：
   - **MySQL**：存储业务数据（用户信息、订单、菜品等）。
   - **Redis**：缓存热点数据（菜品列表、套餐列表）及临时数据（验证码、购物车）。
2. **数据访问层（DAO Layer）**：
   - 使用**MyBatis**框架，通过Mapper接口与数据库交互。
   - 定义POJO实体类与数据库表进行映射。
3. **业务逻辑层（Service Layer）**：
   - 核心业务逻辑处理，如订单状态流转、支付逻辑、报表统计。
   - 利用Spring的`@Transactional`注解控制事务边界。
4. **接口层（Controller Layer）**：
   - 基于RESTful风格定义API接口。
   - 统一封装返回结果`Result<T>`，包含状态码、错误信息和数据。
   - 使用Swagger生成接口文档。
5. **表现层（View Layer）**：
   - **Web端**：Vue.js + Element UI。
   - **移动端**：微信小程序 + Uni-app。

## 4.3 数据库设计

### 4.3.1 数据库概念结构设计

根据需求分析，提炼出以下核心实体：

1. **用户（User）**：包含用户ID、姓名、OpenID、手机号、头像等属性。
2. **员工（Employee）**：包含员工ID、用户名、密码、身份证号、状态等属性。
3. **菜品（Dish）**：包含菜品ID、名称、价格、图片、描述、状态（起售/停售）等属性。
4. **套餐（Setmeal）**：包含套餐ID、名称、价格、图片、描述等属性。
5. **分类（Category）**：包含分类ID、名称、类型（菜品/套餐）、排序等属性。
6. **订单（Orders）**：包含订单ID、订单号、状态、总金额、下单时间、支付方式、地址等属性。

**实体间关系**：

- 一个分类下可以有多个菜品（1:N）。
- 一个套餐可以包含多个菜品（N:M）。
- 一个用户可以下多个订单（1:N）。
- 一个订单包含多个订单明细（1:N）。

### 4.3.2 数据库表结构设计

本系统数据库名为 `food_delivery_system`，包含以下核心数据表。

**1. 员工表（employee）**

| **字段名** | **数据类型** | **长度** | **约束**  | **说明**           |
| ---------- | ------------ | -------- | --------- | ------------------ |
| id         | bigint       | 20       | PK, Auto  | 主键               |
| username   | varchar      | 32       | Unique    | 用户名             |
| password   | varchar      | 64       | Not Null  | 密码（MD5加密）    |
| name       | varchar      | 32       | Not Null  | 姓名               |
| phone      | varchar      | 11       | Not Null  | 手机号             |
| sex        | varchar      | 2        | Not Null  | 性别               |
| id_number  | varchar      | 18       | Not Null  | 身份证号           |
| status     | int          | 11       | Default 1 | 状态 0:禁用 1:启用 |

**2. 用户表（user）**

| **字段名**  | **数据类型** | **长度** | **约束** | **说明**         |
| ----------- | ------------ | -------- | -------- | ---------------- |
| id          | bigint       | 20       | PK, Auto | 主键             |
| openid      | varchar      | 45       | Unique   | 微信用户唯一标识 |
| name        | varchar      | 32       | Nullable | 姓名             |
| phone       | varchar      | 11       | Nullable | 手机号           |
| avatar      | varchar      | 500      | Nullable | 头像             |
| create_time | datetime     | -        | Nullable | 注册时间         |

**3. 分类表（category）**

| **字段名** | **数据类型** | **长度** | **约束**  | **说明**                   |
| ---------- | ------------ | -------- | --------- | -------------------------- |
| id         | bigint       | 20       | PK, Auto  | 主键                       |
| type       | int          | 11       | Not Null  | 类型 1:菜品分类 2:套餐分类 |
| name       | varchar      | 32       | Not Null  | 分类名称                   |
| sort       | int          | 11       | Default 0 | 排序                       |
| status     | int          | 11       | Default 1 | 状态 0:禁用 1:启用         |

**4. 菜品表（dish）**

| **字段名**  | **数据类型** | **长度** | **约束**  | **说明**           |
| ----------- | ------------ | -------- | --------- | ------------------ |
| id          | bigint       | 20       | PK, Auto  | 主键               |
| name        | varchar      | 32       | Not Null  | 菜品名称           |
| category_id | bigint       | 20       | FK        | 菜品分类ID         |
| price       | decimal      | 10,2     | Nullable  | 价格               |
| image       | varchar      | 500      | Nullable  | 图片URL            |
| description | varchar      | 500      | Nullable  | 描述信息           |
| status      | int          | 11       | Default 1 | 状态 0:停售 1:起售 |

**5. 菜品口味表（dish_flavor）**

| **字段名** | **数据类型** | **长度** | **约束** | **说明**                          |
| ---------- | ------------ | -------- | -------- | --------------------------------- |
| id         | bigint       | 20       | PK, Auto | 主键                              |
| dish_id    | bigint       | 20       | FK       | 关联菜品ID                        |
| name       | varchar      | 32       | Nullable | 口味名称（如辣度）                |
| value      | varchar      | 255      | Nullable | 口味数据列表（如["微辣","中辣"]） |

**6. 套餐表（setmeal）**

| **字段名**  | **数据类型** | **长度** | **约束** | **说明**           |
| ----------- | ------------ | -------- | -------- | ------------------ |
| id          | bigint       | 20       | PK, Auto | 主键               |
| category_id | bigint       | 20       | FK       | 套餐分类ID         |
| name        | varchar      | 32       | Not Null | 套餐名称           |
| price       | decimal      | 10,2     | Not Null | 套餐价格           |
| status      | int          | 11       | Nullable | 状态 0:停用 1:启用 |
| image       | varchar      | 500      | Nullable | 图片               |

**7. 套餐菜品关系表（setmeal_dish）**

| **字段名** | **数据类型** | **长度** | **约束** | **说明** |
| ---------- | ------------ | -------- | -------- | -------- |
| id         | bigint       | 20       | PK, Auto | 主键     |
| setmeal_id | bigint       | 20       | FK       | 套餐ID   |
| dish_id    | bigint       | 20       | FK       | 菜品ID   |
| copies     | int          | 11       | Not Null | 份数     |

**8. 订单表（orders）**

| **字段名**      | **数据类型** | **长度** | **约束**  | **说明**                                             |
| --------------- | ------------ | -------- | --------- | ---------------------------------------------------- |
| id              | bigint       | 20       | PK, Auto  | 主键                                                 |
| number          | varchar      | 50       | Unique    | 订单号                                               |
| status          | int          | 11       | Default 1 | 状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消 |
| user_id         | bigint       | 20       | FK        | 下单用户ID                                           |
| address_book_id | bigint       | 20       | FK        | 地址ID                                               |
| order_time      | datetime     | -        | Not Null  | 下单时间                                             |
| pay_method      | int          | 11       | Default 1 | 支付方式 1微信 2支付宝                               |
| amount          | decimal      | 10,2     | Not Null  | 实收金额                                             |

**9. 订单明细表（order_detail）**

| **字段名**  | **数据类型** | **长度** | **约束**  | **说明** |
| ----------- | ------------ | -------- | --------- | -------- |
| id          | bigint       | 20       | PK, Auto  | 主键     |
| order_id    | bigint       | 20       | FK        | 订单ID   |
| dish_id     | bigint       | 20       | FK        | 菜品ID   |
| setmeal_id  | bigint       | 20       | FK        | 套餐ID   |
| dish_flavor | varchar      | 50       | Nullable  | 口味     |
| number      | int          | 11       | Default 1 | 数量     |
| amount      | decimal      | 10,2     | Not Null  | 单价     |

## 4.4 系统功能模块详细设计

### 4.4.1 菜品管理功能详细设计

**业务流程**：

1. 管理员点击“新建菜品”。
2. 前端请求获取“菜品分类”列表。
3. 管理员输入菜品名称、价格，选择分类，上传图片。
4. 管理员设置口味（动态添加，如“甜度”：[无糖, 半糖, 全糖]）。
5. 点击保存，前端将JSON数据发送给 `DishController.save`。
6. 后端开启事务，先向 `dish` 表插入基本信息，获取自增ID，再向 `dish_flavor` 表插入多条口味数据。

### 4.4.2 订单管理功能详细设计

**下单流程**：

1. 用户在小程序购物车点击“去结算”。
2. 前端发送 `OrdersSubmitDTO`，包含地址ID、支付方式、预计送达时间等。
3. 后端校验地址簿有效性、购物车是否为空。
4. 后端生成全局唯一的订单号，计算总金额。
5. 向 `orders` 表插入订单主数据，向 `order_detail` 表批量插入明细数据。
6. 清空Redis中当前用户的购物车数据。
7. 返回订单ID和订单号。

**接单流程**：

1. 商家后台Web端与服务器建立WebSocket连接。
2. 用户支付成功后，后端触发支付成功回调，通过WebSocket向Web端推送JSON消息：`{type: 1, orderId: xxx, content: "订单号：xxx"}`。
3. Web端接收消息，播放提示音，并弹窗提示“您有新的订单”。
4. 商家点击“接单”，前端发送请求更新订单状态为 `CONFIRMED` (3)。

### 4.4.3 数据统计功能详细设计

设计思路：

统计报表涉及大量聚合计算（Sum, Count），为保证性能，对于历史数据（昨天及之前）可以考虑定时任务计算后存入统计表，或者直接基于数据库索引进行实时查询（适用于数据量尚可的情况）。本系统采用实时查询方式。

**逻辑流程**：

1. 前端传入日期范围（如2023-10-01至2023-10-07）。
2. 后端根据日期范围生成日期列表。
3. 遍历每一天，构造 `LocalDateTime` 的开始和结束时间。
4. 调用Mapper接口查询该时间段内状态为“已完成”的订单总金额。
5. 将结果封装为 `TurnoverReportVO` 返回给前端，前端使用ECharts渲染。

## 4.5 本章小结

本章完成了系统的总体设计。首先确定了B/S架构和前后端分离的技术路线；其次详细设计了MySQL数据库的表结构，确保满足第三范式要求；最后对核心业务流程进行了详细的逻辑梳理，为下一章的代码实现提供了蓝图。

# 5 系统实现

## 5.1 开发环境与配置

本系统的开发环境如下：

- **操作系统**：Windows 10 / macOS
- **JDK版本**：Java Development Kit 1.8
- **开发工具**：IntelliJ IDEA 2023
- **数据库**：MySQL 8.0
- **缓存中间件**：Redis 5.0
- **构建工具**：Maven 3.6
- **前端环境**：Node.js 16+, Vue CLI

在 `application.yml` 中配置核心参数：

YAML

```
server:
  port: 8080

spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/food_delivery_system?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8
    username: root
    password: password
  redis:
    host: localhost
    port: 6379
    database: 0
```

## 5.2 用户登录功能的实现

用户登录采用微信小程序授权登录方式。后端接收前端传来的 `code`，调用微信接口获取 `openid`，如果用户不存在则自动注册。

**核心代码 (UserController.java)**：

Java

```
@PostMapping("/login")
@ApiOperation("微信登录")
public Result<UserLoginVO> login(@RequestBody UserLoginDTO userLoginDTO) {
    log.info("微信用户登录：{}", userLoginDTO.getCode());
    
    // 微信登录逻辑，调用service层
    User user = userService.wxLogin(userLoginDTO);

    // 为微信用户生成jwt令牌
    Map<String, Object> claims = new HashMap<>();
    claims.put(JwtClaimsConstant.USER_ID, user.getId());
    String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);

    UserLoginVO userLoginVO = UserLoginVO.builder()
            .id(user.getId())
            .openid(user.getOpenid())
            .token(token)
            .build();
    return Result.success(userLoginVO);
}
```

## 5.3 菜品管理功能的实现

菜品新增功能不仅要保存菜品本身的信息，还要保存关联的口味信息（如辣度、甜度），涉及到两张表的操作，因此需要使用 `@Transactional` 注解保证事务一致性。

**核心代码 (DishServiceImpl.java)**：

Java

```
@Transactional
public void addWithFlavor(DishDTO dishDTO) {
    // 1. 保存菜品基本信息
    Dish dish = new Dish();
    BeanUtils.copyProperties(dishDTO, dish);
    dishMapper.insert(dish);
    
    // 获取insert语句生成的主键菜品id
    Long dishId = dish.getId();
    
    // 2. 保存口味信息
    List<DishFlavor> flavors = dishDTO.getFlavors();
    if (flavors != null && flavors.size() > 0) {
        flavors.forEach(flavor -> flavor.setDishId(dishId));
        // 批量插入
        dishFlavorMapper.insertFlavor(flavors);
    }
}
```

## 5.4 订单管理功能的实现

### 5.4.1 用户下单

用户下单是系统最复杂的功能之一，需要校验地址、清空购物车、计算金额、保存订单及明细。

**核心代码 (OrderServiceImpl.java)**：

Java

```
@Transactional
public OrderSubmitVO submit(OrdersSubmitDTO ordersSubmitDTO) {
    // 1. 处理异常（地址簿为空、购物车为空等）
    // ...

    // 2. 向订单表插入一条数据
    Orders orders = new Orders();
    BeanUtils.copyProperties(ordersSubmitDTO, orders);
    orders.setOrderTime(LocalDateTime.now());
    orders.setPayStatus(Orders.UN_PAID);
    orders.setStatus(Orders.PENDING_PAYMENT);
    orders.setNumber(String.valueOf(System.currentTimeMillis())); // 生成订单号
    orderMapper.insert(orders);

    // 3. 向订单明细表批量插入数据
    List<OrderDetail> orderDetails = new ArrayList<>();
    for (ShoppingCart cart : shoppingCartList) {
        OrderDetail orderDetail = new OrderDetail();
        BeanUtils.copyProperties(cart, orderDetail);
        orderDetail.setOrderId(orders.getId());
        orderDetails.add(orderDetail);
    }
    orderDetailMapper.insertBatch(orderDetails);

    // 4. 清空购物车
    shoppingCartMapper.deleteByUserId(BaseContext.getCurrentId());

    // 5. 返回VO
    return OrderSubmitVO.builder()
            .id(orders.getId())
            .orderNumber(orders.getNumber())
            .orderAmount(orders.getAmount())
            .orderTime(orders.getOrderTime())
            .build();
}
```

### 5.4.2 商家接单提醒 (WebSocket)

为了实现实时的接单提醒，系统使用了WebSocket技术。

**核心代码 (WebSocketServer.java)**：

Java

```
/**
 * 群发消息
 * @param message
 */
public void sendToAllClient(String message) {
    for (Session session : sessionMap.values()) {
        try {
            session.getBasicRemote().sendText(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

在支付成功的回调逻辑中调用推送：

Java

```
// OrderServiceImpl.java
Map<String, Object> map = new HashMap<>();
map.put("type", 1); // 1表示来单提醒 2表示客户催单
map.put("orderId", orders.getId());
map.put("content", "订单号：" + orders.getNumber());

String json = JSON.toJSONString(map);
webSocketServer.sendToAllClient(json);
```

## 5.5 数据统计功能的实现

数据统计功能通过聚合查询计算指定日期范围内的营业额。

**核心代码 (ReportServiceImpl.java)**：

Java

```
public TurnoverReportVO turnoverStatistics(LocalDate begin, LocalDate end) {
    List<LocalDate> dateList = new ArrayList<>();
    List<Double> turnoverList = new ArrayList<>();

    // 遍历日期范围
    while (!begin.equals(end.plusDays(1))) {
        LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(begin, LocalTime.MAX);
        
        // 查询当天的已完成订单总金额
        Map<String, Object> map = new HashMap<>();
        map.put("begin", beginTime);
        map.put("end", endTime);
        map.put("status", Orders.COMPLETED);
        
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null ? 0.0 : turnover;
        
        dateList.add(begin);
        turnoverList.add(turnover);
        
        begin = begin.plusDays(1);
    }
    
    // 封装返回
    return TurnoverReportVO.builder()
            .dateList(StringUtils.join(dateList, ","))
            .turnoverList(StringUtils.join(turnoverList, ","))
            .build();
}
```

## 5.6 本章小结

本章展示了“云味道”系统的核心代码实现。通过Spring Boot的注解开发大大简化了事务管理和依赖注入；利用WebSocket实现了服务器向客户端的实时消息推送，解决了传统轮询机制的弊端；通过MyBatis的动态SQL和聚合查询，高效地实现了复杂报表的统计功能。

------

# 6 系统测试

## 6.1 测试方案

本系统采用黑盒测试方法，即不考虑程序内部结构和逻辑，仅根据需求规格说明书，检查程序的功能是否符合预期。测试范围覆盖了管理员端和用户端的主要业务流程。

**测试环境**：

- **服务端**：阿里云 ECS (2核 4G) / 本地开发机
- **客户端**：iPhone 13 (微信小程序), Chrome 浏览器 v118

## 6.2 功能测试

### 6.2.1 登录与注册测试

| **序号** | **测试场景** | **操作步骤**               | **预期结果**                               | **实际结果** | **结论** |
| -------- | ------------ | -------------------------- | ------------------------------------------ | ------------ | -------- |
| 1        | 微信一键登录 | 在小程序端点击“微信登录”   | 弹出授权框，确认后跳转至首页，显示用户头像 | 与预期一致   | 通过     |
| 2        | 管理员登录   | 输入正确的账号admin和密码  | 成功进入后台管理首页                       | 与预期一致   | 通过     |
| 3        | 密码错误     | 输入正确的账号和错误的密码 | 提示“账号或密码错误”                       | 与预期一致   | 通过     |

### 6.2.2 菜品管理模块测试

| **序号** | **测试场景**     | **操作步骤**                       | **预期结果**                     | **实际结果** | **结论** |
| -------- | ---------------- | ---------------------------------- | -------------------------------- | ------------ | -------- |
| 1        | 新增菜品         | 输入完整信息（含图片、口味）并保存 | 列表页显示新菜品，状态默认为停售 | 与预期一致   | 通过     |
| 2        | 图片上传格式错误 | 上传.txt文件                       | 提示“请上传图片格式文件”         | 与预期一致   | 通过     |
| 3        | 修改价格         | 将菜品价格由20改为25               | 保存后列表显示价格为25           | 与预期一致   | 通过     |

### 6.2.3 订单流转测试

| **序号** | **测试场景** | **操作步骤**                       | **预期结果**                                 | **实际结果** | **结论** |
| -------- | ------------ | ---------------------------------- | -------------------------------------------- | ------------ | -------- |
| 1        | 用户下单     | 选择菜品，提交订单并支付           | 小程序提示支付成功，订单状态变为“待接单”     | 与预期一致   | 通过     |
| 2        | 商家接单     | 商家在后台收到语音提示，点击“接单” | 订单状态变为“待派送”，用户端显示“商家已接单” | 与预期一致   | 通过     |
| 3        | 商家拒单     | 商家点击“拒单”并填写原因           | 订单状态变为“已取消”，系统自动发起退款       | 与预期一致   | 通过     |

## 6.3 性能测试

使用 Apache JMeter 对“用户浏览菜品列表”接口进行压力测试。

- **线程数**：100
- **循环次数**：10
- **测试结果**：平均响应时间为 120ms，吞吐量（TPS）达到 800/s，无错误请求。说明Redis缓存策略有效提升了查询性能。

## 6.4 本章小结

经过多轮测试，系统各项功能运行稳定，业务逻辑闭环，异常处理机制完善。在高并发场景下，得益于Redis缓存的应用，系统依然保持了良好的响应速度，满足了设计之初的非功能性需求。

------

# 7 总结与展望

## 7.1 总结

本文设计并实现了一套基于Spring Boot和微信小程序的“云味道”外卖点餐系统。在开发过程中，完成了以下主要工作：

1. **需求分析与架构设计**：深入调研了外卖行业的痛点，确定了系统的功能边界。采用了前后端分离的B/S架构，后端基于Spring Boot，前端结合Vue.js和微信小程序，实现了多端协同。
2. **核心功能开发**：实现了从菜品维护、用户下单、在线支付、商家接单到骑手配送的全流程业务闭环。特别是在订单模块，利用Redis缓存购物车数据，利用WebSocket实现接单提醒，极大提升了用户体验和运营效率。
3. **数据可视化**：构建了完善的数据统计模块，帮助商家通过图表直观了解经营状况，体现了数据赋能业务的价值。
4. **系统测试**：通过黑盒测试和简单的性能测试，验证了系统的可用性和稳定性。

## 7.2 展望

受限于时间和个人能力，本系统仍存在一些不足之处，未来可在以下方面进行改进：

1. **推荐算法引入**：目前首页菜品仅按分类展示。未来可引入协同过滤推荐算法，根据用户的历史订单数据，为用户推荐可能喜欢的菜品，实现千人千面。
2. **配送路径优化**：目前仅实现了简单的派送状态流转。未来可结合地图API（如高德地图），为骑手规划最优配送路线，进一步提高配送效率。
3. **多商户支持**：目前的系统仅支持单店模式。未来可进行架构升级，支持多商户入驻，演变为类似于美团的聚合平台模式。

------

# 参考文献

[1] 张三. 基于Spring Boot的微服务架构设计与实现[J]. 计算机科学, 2022, 49(10): 123-128.

[2] 李四. 微信小程序开发实战[M]. 北京: 人民邮电出版社, 2021.

[3] 王五. Redis设计与实现[M]. 北京: 机械工业出版社, 2020.

[4] Spring Boot Documentation. https://spring.io/projects/spring-boot

[5] Vue.js Guide. https://vuejs.org/

------

# 致谢

时光荏苒，大学四年的生活即将画上句号。回首这段求学经历，感慨万千。

首先，我要衷心感谢我的指导老师。在论文的选题、开题、设计到最终定稿的每一个环节，老师都给予了我耐心细致的指导。老师严谨的治学态度和深厚的学术造诣深深影响了我，让我受益终身。

其次，感谢我的同学们。在系统开发遇到Bug卡壳时，是你们与我一起探讨解决方案，帮我度过了无数个熬夜的夜晚。

最后，感谢我的父母，是你们默默的支持和无私的奉献，让我能够心无旁骛地完成学业。

愿我们在未来的道路上，都能保持初心，砥砺前行！